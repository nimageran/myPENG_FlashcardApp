<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Nima Flashcards â€” NPPE (Light + Audio, Image on Back)</title>
  <meta name="theme-color" content="#f8fafc" />
  <style>
    :root{
      /* Light theme */
      --bg:#ffffff;         /* page background */
      --surface:#f8fafc;    /* card background */
      --border:#e5e7eb;     /* light border */
      --ink:#0f172a;        /* primary text */
      --muted:#64748b;      /* secondary text */
      --accent:#2563eb;     /* primary accent */
      --accent-ink:#ffffff; /* text on accent */
      --danger:#ef4444;
      --radius:18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Inter,Roboto,Arial}
    .wrap{max-width:min(900px, 92vw);margin:0 auto;padding:env(safe-area-inset-top) clamp(12px,2.5vw,24px) 40px}
    header{position:sticky;top:0;background:linear-gradient(to bottom, rgba(255,255,255,.95), rgba(255,255,255,0));backdrop-filter:saturate(1.2) blur(8px);z-index:10;padding:10px 0 12px}
    h1{font-size:clamp(18px,2vw,22px);margin:0;letter-spacing:.2px}

    /* Controls */
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .btn{padding:12px 16px;border-radius:14px;border:1px solid var(--border);background:#fff;color:var(--ink);cursor:pointer;min-height:44px;min-width:44px}
    .btn.primary{background:var(--accent);color:var(--accent-ink);border-color:#1d4ed8;font-weight:600}
    .btn.ghost{background:transparent}
    .pill{padding:8px 12px;border-radius:999px;border:1px solid var(--border);color:var(--muted);font-size:13px;background:#fff}
    .select,.chk,.range{padding:10px 12px;border-radius:12px;border:1px solid var(--border);background:#fff;color:var(--ink);min-height:44px}
    .range{padding:0;height:44px}

    /* Card */
    main.card{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:clamp(12px,2.5vw,18px)}
    .big{font-size:clamp(18px,3.2vw,28px);line-height:1.35;text-align:center;min-height:clamp(120px,30vh,260px);padding:clamp(12px,2.5vw,18px);user-select:none}
    .img{max-width:100%;max-height:38vh;display:block;margin:6px auto 8px;border-radius:12px;border:1px solid var(--border)}
    .muted{color:var(--muted);font-size:13px}
    .grid{display:grid;gap:12px}
    .actions{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
    .hide{display:none!important}
    .foot{color:var(--muted);font-size:12px;text-align:center;padding:14px 6px}
    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;background:#ffffff;border:1px solid var(--border);border-radius:8px;padding:2px 6px;font-size:12px;color:#0f172a}

    /* iPhone-friendly touch area */
    .btn, .select, .chk { touch-action: manipulation; }
  </style>
</head>
<body>
<div class="wrap">
  <header class="row" style="justify-content:space-between">
    <h1>Flashcards â€” NPPE (Nima)</h1>
    <div class="row">
      <span id="status" class="pill">Loading deckâ€¦</span>
      <button id="start" class="btn primary hide">Start</button>
      <button id="resetProgress" class="btn ghost" title="Clear known/unknown marks">Reset</button>
    </div>
  </header>

  <!-- Top controls: stats + mode + audio settings -->
  <div class="row" style="justify-content:space-between;margin:6px 0 12px">
    <div class="row" style="gap:8px;flex-wrap:wrap">
      <span class="pill">Total: <b id="statTotal">0</b></span>
      <span class="pill">Known: <b id="statKnown">0</b></span>
      <span class="pill">Unknown: <b id="statUnknown">0</b></span>
      <span class="pill">Seen: <b id="statSeen">0</b></span>
    </div>
    <div class="row" style="gap:8px">
      <label class="row"><span class="pill">Mode</span>
        <select id="mode" class="select">
          <option value="ordered">Ordered</option>
          <option value="random" selected>Random</option>
        </select>
      </label>
      <label class="row"><span class="pill">Skip Known</span>
        <input id="skipKnown" type="checkbox" class="chk" checked />
      </label>
    </div>
  </div>

  <main class="card grid">
    <div class="row" style="justify-content:space-between;align-items:center">
      <div class="muted">Tap card (or <span class="kbd">Space</span>) to flip</div>
      <div class="row" style="gap:8px">
        <span class="pill">Index: <b id="indexLabel">â€“</b></span>
        <span class="pill">Audio
          <select id="voiceSel" class="select" style="min-width:160px"></select>
        </span>
        <span class="pill">Rate <input id="rate" class="range" type="range" min="0.6" max="1.4" value="1" step="0.1" style="width:110px"></span>
        <label class="pill">Auto Front <input id="speakFront" type="checkbox" class="chk" checked></label>
        <label class="pill">Auto Back <input id="speakBack" type="checkbox" class="chk" checked></label>
      </div>
    </div>

    <div id="face" class="big">Place your CSV at <code>assets/cards.csv</code> with columns: <b>id,front,back</b>. Images are autoâ€‘matched by ID: <code>assets/images/&lt;id&gt;.png</code> (or .jpg/.jpeg/.webp/.svg). Images show <b>only on the back</b>.</div>
    <img id="img" class="img hide" alt="" />

    <div class="actions">
      <button id="again" class="btn">I don't know</button>
      <button id="flip" class="btn">Flip</button>
      <button id="good" class="btn primary">I know</button>
      <button id="next" class="btn">Next</button>
    </div>
  </main>

  <div class="foot">Shortcuts: <span class="kbd">Space</span> flip Â· <span class="kbd">â†’</span> next Â· <span class="kbd">1</span> unknown Â· <span class="kbd">2</span> known</div>
</div>

<script>
// ===== Nima NPPE Flashcards (Light + Auto Audio) =====
// Auto-loads assets/cards.csv (id,front,back)
// Random/Ordered, Known/Unknown, local progress
// Auto text-to-speech on flip / next (after first user gesture)
// Image mapping by ID: assets/images/<id>.(png|jpg|jpeg|webp|svg)
// Images appear ONLY on the BACK side

const CSV_URL = 'assets/cards.csv';
const STORAGE_KEY = 'nppe_cards_progress_v3';
const AUDIO_KEY = 'nppe_audio_prefs_v1';

let deck = [];          // [{id,front,back,known:false,seen:0}]
let cursor = -1;        // current index
let showingBack = false;
let voices = [];
let voiceReady = false;
let audioPrefs = { voiceURI: '', rate: 1, speakFront: true, speakBack: true };

// Elements
const $ = s => document.querySelector(s);
const face = $('#face');
const img  = $('#img');
const status = $('#status');
const startBtn = $('#start');
const modeSel = $('#mode');
const skipKnownChk = $('#skipKnown');
const idxLabel = $('#indexLabel');
const statTotal = $('#statTotal');
const statKnown = $('#statKnown');
const statUnknown = $('#statUnknown');
const statSeen = $('#statSeen');
const voiceSel = $('#voiceSel');
const rateIn = $('#rate');
const speakFrontChk = $('#speakFront');
const speakBackChk = $('#speakBack');

// --- Init ---
(async function init(){
  // Load audio prefs
  try{ const raw = localStorage.getItem(AUDIO_KEY); if(raw) Object.assign(audioPrefs, JSON.parse(raw)); }catch(e){}
  rateIn.value = audioPrefs.rate;
  speakFrontChk.checked = !!audioPrefs.speakFront;
  speakBackChk.checked = !!audioPrefs.speakBack;

  await loadVoices();
  populateVoiceSelect();

  try {
    const text = await (await fetch(CSV_URL, {cache:'no-store'})).text();
    const rows = parseCSV(text);
    if(!rows.length) throw new Error('CSV empty');
    // header detection (id,front,back) case-insensitive
    const header = rows[0].map?.(x=> String(x||'').toLowerCase().trim());
    const hasHeader = header && header[0]==='id' && header[1]==='front' && header[2]==='back';
    const data = (hasHeader ? rows.slice(1) : rows).filter(r => (r[0]||'').trim() && (r[1]||'').trim() && (r[2]||'').trim());
    deck = data.map((r,i)=> ({ id:(r[0]||`row${i}`).trim(), front:(r[1]||'').trim(), back:(r[2]||'').trim(), known:false, seen:0 }));
    loadProgress();
    status.textContent = 'Deck loaded';
    startBtn.classList.remove('hide');
    updateStats();
    face.innerHTML = 'Ready. Click <b>Start</b> (enables speech on iPhone) or press <span class="kbd">â†’</span>.';
  } catch (e) {
    status.textContent = 'No CSV found';
    face.innerHTML = 'Create <code>assets/cards.csv</code> with columns: <b>id,front,back</b>.';
  }
})();

startBtn.addEventListener('click', ()=> { start(); warmUpSpeech(); });
$('#next').addEventListener('click', ()=> { next(); });
$('#flip').addEventListener('click', ()=> { flip(); });
$('#good').addEventListener('click', ()=> grade(true));
$('#again').addEventListener('click', ()=> grade(false));
$('#resetProgress').addEventListener('click', ()=>{ if(confirm('Clear Known/Unknown and Seen counts?')){ deck.forEach(c=>{c.known=false;c.seen=0}); saveProgress(); updateStats(); renderFace(); }});

// Keyboard (desktop/laptop)
addEventListener('keydown', (e)=>{
  if(e.key===' '){ e.preventDefault(); flip(); }
  if(e.key==='ArrowRight'){ next(); }
  if(e.key==='1'){ grade(false); }
  if(e.key==='2'){ grade(true); }
});

// Audio controls
voiceSel.addEventListener('change', ()=>{ audioPrefs.voiceURI = voiceSel.value; saveAudioPrefs(); });
rateIn.addEventListener('input', ()=>{ audioPrefs.rate = parseFloat(rateIn.value)||1; saveAudioPrefs(); });
speakFrontChk.addEventListener('change', ()=>{ audioPrefs.speakFront = speakFrontChk.checked; saveAudioPrefs(); });
speakBackChk.addEventListener('change', ()=>{ audioPrefs.speakBack = speakBackChk.checked; saveAudioPrefs(); });

function start(){ cursor = -1; showingBack = false; next(); }

function eligibleIndices(){
  const skipKnown = skipKnownChk.checked;
  const mode = modeSel.value;
  let indices = deck.map((_,i)=>i);
  if(skipKnown) indices = indices.filter(i => !deck[i].known);
  if(mode==='ordered'){
    const start = Math.max(cursor+1,0);
    const tail = indices.filter(i=> i>=start);
    const head = indices.filter(i=> i<start);
    return tail.length ? tail : head; // wrap-around
  } else return indices;
}

function next(){
  if(!deck.length) return;
  const mode = modeSel.value;
  const choices = eligibleIndices();
  if(!choices.length){
    face.innerHTML = 'All done ðŸŽ‰ Reset or uncheck <b>Skip Known</b> to review again.';
    hideImage();
    idxLabel.textContent = 'â€“';
    return;
  }
  cursor = (mode==='random') ? choices[Math.floor(Math.random()*choices.length)] : choices[0];
  deck[cursor].seen++; saveProgress(); showingBack = false; renderFace(true);
}

function flip(){ if(cursor<0) return; showingBack = !showingBack; renderFace(false); }

function grade(known){ if(cursor<0) return; deck[cursor].known = known; saveProgress(); updateStats(); next(); }

function renderFace(spokeOnFront){
  if(cursor<0){ face.textContent = 'Press Start'; return; }
  const c = deck[cursor];
  idxLabel.textContent = `${cursor+1}/${deck.length}`;
  face.innerHTML = showingBack ? escape(c.back) : escape(c.front);
  if(showingBack){ showImageForId(c.id); } else { hideImage(); }
  updateStats();
  autoSpeakCurrent(spokeOnFront);
}

// ===== Image loading (by ID) =====
function hideImage(){ img.classList.add('hide'); img.removeAttribute('src'); img.alt=''; }
function showImageForId(id){
  const exts = ['png','jpg','jpeg','webp','svg'];
  let i = 0;
  const tryNext = () => {
    if(i>=exts.length){ hideImage(); return; }
    const src = `assets/images/${id}.${exts[i++]}`;
    img.onerror = tryNext;
    img.onload = () => { img.onerror = null; img.alt = id; img.classList.remove('hide'); };
    img.src = src;
  };
  tryNext();
}

function updateStats(){
  const total = deck.length;
  const known = deck.filter(c=>c.known).length;
  const seen = deck.reduce((a,c)=> a + (c.seen>0?1:0), 0);
  statTotal.textContent = total;
  statKnown.textContent = known;
  statUnknown.textContent = Math.max(0,total-known);
  statSeen.textContent = seen;
}

function saveProgress(){ const payload = deck.map(c=>({id:c.id,known:c.known,seen:c.seen})); localStorage.setItem(STORAGE_KEY, JSON.stringify(payload)); }
function loadProgress(){ try{ const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return; const arr = JSON.parse(raw); const map = new Map(arr.map(x=>[x.id,x])); deck.forEach(c=>{ const m = map.get(c.id); if(m){ c.known=!!m.known; c.seen=m.seen|0; } }); }catch(e){} }
function saveAudioPrefs(){ localStorage.setItem(AUDIO_KEY, JSON.stringify(audioPrefs)); }

// ===== Text-To-Speech =====
function loadVoices(){
  return new Promise(res=>{
    const handler = ()=>{ voices = speechSynthesis.getVoices(); if(voices && voices.length){ voiceReady=true; speechSynthesis.removeEventListener('voiceschanged', handler); res(); } };
    speechSynthesis.addEventListener('voiceschanged', handler);
    // also try immediately
    voices = speechSynthesis.getVoices(); if(voices && voices.length){ voiceReady=true; speechSynthesis.removeEventListener('voiceschanged', handler); res(); }
    // fallback timeout
    setTimeout(()=>{ voices = speechSynthesis.getVoices(); voiceReady=true; res(); }, 800);
  });
}
function populateVoiceSelect(){
  voiceSel.innerHTML = '';
  const opts = voices.length ? voices : [{name:'Default', voiceURI:''}];
  // Prefer English (Canada/US) voices at top
  const sorted = opts.slice().sort((a,b)=>{
    const la=(a.lang||'').toLowerCase(), lb=(b.lang||'').toLowerCase();
    const pa = (la.includes('en-ca')||la.includes('en-us'))?0:1;
    const pb = (lb.includes('en-ca')||lb.includes('en-us'))?0:1;
    return pa-pb || (a.name||'').localeCompare(b.name||'');
  });
  for(const v of sorted){
    const o = document.createElement('option');
    o.value = v.voiceURI || v.name || '';
    o.textContent = v.name ? `${v.name} (${v.lang||''})` : 'Default';
    voiceSel.appendChild(o);
  }
  // restore selection
  if(audioPrefs.voiceURI){ voiceSel.value = audioPrefs.voiceURI; }
}
function speak(text){
  try{ speechSynthesis.cancel(); }catch(e){}
  if(!text || !('speechSynthesis' in window)) return;
  const u = new SpeechSynthesisUtterance(text);
  u.rate = audioPrefs.rate||1;
  // select voice by URI or name
  const v = voices.find(v=> v.voiceURI===audioPrefs.voiceURI || v.name===audioPrefs.voiceURI);
  if(v) u.voice = v;
  // Some iOS versions need a small delay after user gesture
  setTimeout(()=>{ try{ speechSynthesis.speak(u); }catch(e){} }, 0);
}
function warmUpSpeech(){
  // Call once after a user gesture to satisfy iOS autoplay policy
  if(!('speechSynthesis' in window)) return;
  const u = new SpeechSynthesisUtterance('');
  try{ speechSynthesis.speak(u); speechSynthesis.cancel(); }catch(e){}
}
function autoSpeakCurrent(spokeOnFront){
  const c = deck[cursor];
  if(!c) return;
  const shouldSpeak = showingBack ? audioPrefs.speakBack : audioPrefs.speakFront;
  if(!shouldSpeak) return;
  const txt = showingBack ? c.back : c.front;
  speak(txt);
}

// ===== CSV Parser (RFC4180-ish) =====
function parseCSV(str){
  const rows=[]; let row=[]; let cur=''; let i=0, inQ=false;
  while(i<str.length){
    const ch=str[i];
    if(inQ){
      if(ch==='"'){
        if(str[i+1]==='"'){ cur+='"'; i+=2; continue; }
        inQ=false; i++; continue;
      } else { cur+=ch; i++; continue; }
    } else {
      if(ch==='"'){ inQ=true; i++; continue; }
      if(ch===','){ row.push(cur); cur=''; i++; continue; }
      if(ch==='\n'){ row.push(cur); rows.push(row); row=[]; cur=''; i++; continue; }
      if(ch==='\r'){ i++; continue; }
      cur+=ch; i++;
    }
  }
  row.push(cur); rows.push(row);
  return rows.filter(r=> r.length>1 || (r.length===1 && r[0].trim()!==''));
}
function escape(s){ return (s||'').replace(/[&<>]/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[m])); }
</script>
</body>
</html>
