<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Nima Flashcards â€” NPPE (ID = card<number>)</title>
  <meta name="theme-color" content="#f8fafc" />
  <style>
    :root{ --bg:#ffffff; --surface:#f8fafc; --border:#e5e7eb; --ink:#0f172a; --muted:#64748b; --accent:#2563eb; --accent-ink:#ffffff; --radius:18px; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Inter,Roboto,Arial}
    .wrap{max-width:min(900px,92vw);margin:0 auto;padding:env(safe-area-inset-top) clamp(12px,2.5vw,24px) 40px}
    header{position:sticky;top:0;background:linear-gradient(to bottom,rgba(255,255,255,.95),rgba(255,255,255,0));backdrop-filter:saturate(1.2) blur(8px);z-index:10;padding:10px 0 12px}
    h1{font-size:clamp(18px,2vw,22px);margin:0}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .btn{padding:12px 16px;border-radius:14px;border:1px solid var(--border);background:#fff;color:var(--ink);cursor:pointer;min-height:44px;min-width:44px}
    .btn.primary{background:var(--accent);color:var(--accent-ink);border-color:#1d4ed8;font-weight:600}
    .pill{padding:8px 12px;border-radius:999px;border:1px solid var(--border);color:var(--muted);font-size:13px;background:#fff}
    .select,.chk,.range{padding:10px 12px;border-radius:12px;border:1px solid var(--border);background:#fff;color:var(--ink);min-height:44px}
    main.card{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:clamp(12px,2.5vw,18px)}
    .big{font-size:clamp(18px,3.2vw,28px);line-height:1.35;text-align:center;min-height:clamp(120px,30vh,260px);padding:clamp(12px,2.5vw,18px);user-select:none}
    .img{max-width:100%;max-height:38vh;display:block;margin:6px auto 8px;border-radius:12px;border:1px solid var(--border)}
    .muted{color:var(--muted);font-size:13px}
    .grid{display:grid;gap:12px}
    .actions{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
    .hide{display:none!important}
    .foot{color:var(--muted);font-size:12px;text-align:center;padding:14px 6px}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#fff;border:1px solid var(--border);border-radius:8px;padding:2px 6px;font-size:12px;color:#0f172a}
  </style>
</head>
<body>
<div class="wrap">
  <header class="row" style="justify-content:space-between">
    <h1>Flashcards â€” NPPE (Nima)</h1>
    <div class="row">
      <span id="status" class="pill">Loading deckâ€¦</span>
      <button id="start" class="btn primary hide">Start</button>
      <button id="resetProgress" class="btn" title="Clear known/unknown marks">Reset</button>
    </div>
  </header>

  <div class="row" style="justify-content:space-between;margin:6px 0 12px">
    <div class="row" style="gap:8px;flex-wrap:wrap">
      <span class="pill">Total: <b id="statTotal">0</b></span>
      <span class="pill">Known: <b id="statKnown">0</b></span>
      <span class="pill">Unknown: <b id="statUnknown">0</b></span>
      <span class="pill">Seen: <b id="statSeen">0</b></span>
    </div>
    <div class="row" style="gap:8px">
      <label class="row"><span class="pill">Mode</span>
        <select id="mode" class="select">
          <option value="ordered">Ordered</option>
          <option value="random" selected>Random</option>
        </select>
      </label>
      <label class="row"><span class="pill">Skip Known</span>
        <input id="skipKnown" type="checkbox" class="chk" checked />
      </label>
    </div>
  </div>

  <main class="card grid">
    <div class="row" style="justify-content:space-between;align-items:center">
      <div class="muted">Tap card (or <span class="kbd">Space</span>) to flip</div>
      <div class="row" style="gap:8px">
        <!-- We now show only the stable ID in the label to match image filenames -->
        <span class="pill">ID: <b id="indexLabel">â€“</b></span>
      </div>
    </div>

    <div id="face" class="big">Place your CSV at <code>assets/cards.csv</code> with columns: <b>id,front,back</b>. IDs will be normalized to <code>card&lt;number&gt;</code> automatically. Images are matched by ID and show <b>only on the back</b>.</div>
    <img id="img" class="img hide" alt="" />

    <div class="actions">
      <button id="again" class="btn">I don't know</button>
      <button id="flip" class="btn">Flip</button>
      <button id="good" class="btn primary">I know</button>
      <button id="next" class="btn">Next</button>
    </div>
  </main>

  <div class="foot">Images live at <code>assets/images/card&lt;number&gt;.png</code> (or .jpg/.webp/.svg). Shortcuts: <span class="kbd">Space</span> flip Â· <span class="kbd">â†’</span> next Â· <span class="kbd">1</span> unknown Â· <span class="kbd">2</span> known</div>
</div>

<script>
// ===== Nima NPPE Flashcards â€” IDs normalized to card<number> =====
// CSV columns: id,front,back
// We normalize every id to the safe pattern: card<number>
// Examples:  "21" -> "card21" , "Card003" -> "card3" , "card12" stays "card12".
// Image mapping: assets/images/card<number>.(png|jpg|jpeg|webp|svg)
// Images show ONLY on the BACK side

const CSV_URL = 'assets/cards.csv';
const STORAGE_KEY = 'nppe_cards_progress_v4';

let deck = [];          // [{id,front,back,known:false,seen:0}]
let cursor = -1;        // current index
let showingBack = false;

// Elements
const $ = s => document.querySelector(s);
const face = $('#face');
const img  = $('#img');
const status = $('#status');
const startBtn = $('#start');
const modeSel = $('#mode');
const skipKnownChk = $('#skipKnown');
const idxLabel = $('#indexLabel');
const statTotal = $('#statTotal');
const statKnown = $('#statKnown');
const statUnknown = $('#statUnknown');
const statSeen = $('#statSeen');

(async function init(){
  try {
    const text = await (await fetch(CSV_URL, {cache:'no-store'})).text();
    const rows = parseCSV(text);
    if(!rows.length) throw new Error('CSV empty');
    // Detect header id,front,back (case-insensitive)
    const header = rows[0].map?.(x=> String(x||'').toLowerCase().trim());
    const hasHeader = header && header[0]==='id' && header[1]==='front' && header[2]==='back';
    const data = (hasHeader ? rows.slice(1) : rows).filter(r => (r[0]||'').trim() && (r[1]||'').trim() && (r[2]||'').trim());

    deck = data.map((r,i)=> ({
      // Normalize id to card<number>
      id: normalizeId(r[0]||`card${i+1}`),
      front:(r[1]||'').trim(),
      back:(r[2]||'').trim(),
      known:false,
      seen:0
    }));

    // If any dup IDs after normalization, make them unique by appending suffix
    const seen = new Set();
    for(const c of deck){
      let original = c.id; let n=2;
      while(seen.has(c.id)) { c.id = `${original}-${n++}`; }
      seen.add(c.id);
    }

    loadProgress();
    status.textContent = 'Deck loaded';
    startBtn.classList.remove('hide');
    updateStats();
    face.innerHTML = 'Ready. Click <b>Start</b>.';
  } catch (e) {
    status.textContent = 'No CSV found';
    face.innerHTML = 'Create <code>assets/cards.csv</code> with columns: <b>id,front,back</b>.';
  }
})();

startBtn.addEventListener('click', ()=> { start(); });
$('#next').addEventListener('click', ()=> { next(); });
$('#flip').addEventListener('click', ()=> { flip(); });
$('#good').addEventListener('click', ()=> grade(true));
$('#again').addEventListener('click', ()=> grade(false));
$('#resetProgress').addEventListener('click', ()=>{ if(confirm('Clear Known/Unknown and Seen counts?')){ deck.forEach(c=>{c.known=false;c.seen=0}); saveProgress(); updateStats(); renderFace(); }});

document.addEventListener('keydown', (e)=>{
  if(e.key===' '){ e.preventDefault(); flip(); }
  if(e.key==='ArrowRight'){ next(); }
  if(e.key==='1'){ grade(false); }
  if(e.key==='2'){ grade(true); }
});

function start(){ cursor = -1; showingBack = false; next(); }

function eligibleIndices(){
  const skipKnown = skipKnownChk.checked;
  const mode = modeSel.value;
  let indices = deck.map((_,i)=>i);
  if(skipKnown) indices = indices.filter(i => !deck[i].known);
  if(mode==='ordered'){
    const start = Math.max(cursor+1,0);
    const tail = indices.filter(i=> i>=start);
    const head = indices.filter(i=> i<start);
    return tail.length ? tail : head; // wrap-around
  } else return indices;
}

function next(){
  if(!deck.length) return;
  const mode = modeSel.value;
  const choices = eligibleIndices();
  if(!choices.length){
    face.innerHTML = 'All done ðŸŽ‰ Reset or uncheck <b>Skip Known</b> to review again.';
    hideImage();
    idxLabel.textContent = 'â€“';
    return;
  }
  cursor = (mode==='random') ? choices[Math.floor(Math.random()*choices.length)] : choices[0];
  deck[cursor].seen++; saveProgress(); showingBack = false; renderFace();
}

function flip(){ if(cursor<0) return; showingBack = !showingBack; renderFace(); }

function grade(known){ if(cursor<0) return; deck[cursor].known = known; saveProgress(); updateStats(); next(); }

function renderFace(){
  if(cursor<0){ face.textContent = 'Press Start'; return; }
  const c = deck[cursor];
  // Show the stable ID ONLY (so you know exact image filename)
  idxLabel.textContent = c.id;
  face.innerHTML = showingBack ? escape(c.back) : escape(c.front);
  if(showingBack){ showImageForId(c.id); } else { hideImage(); }
  updateStats();
}

// ===== Image loading by ID =====
function hideImage(){ img.classList.add('hide'); img.removeAttribute('src'); img.alt=''; }
function showImageForId(id){
  const exts = ['png','jpg','jpeg','webp','svg'];
  let i = 0;
  const tryNext = () => {
    if(i>=exts.length){ hideImage(); return; }
    const src = `assets/images/${id}.${exts[i++]}`;
    img.onerror = tryNext;
    img.onload = () => { img.onerror = null; img.alt = id; img.classList.remove('hide'); };
    img.src = src;
  };
  tryNext();
}

function updateStats(){
  const total = deck.length;
  const known = deck.filter(c=>c.known).length;
  const seen = deck.reduce((a,c)=> a + (c.seen>0?1:0), 0);
  statTotal.textContent = total;
  statKnown.textContent = known;
  statUnknown.textContent = Math.max(0,total-known);
  statSeen.textContent = seen;
}

function saveProgress(){ const payload = deck.map(c=>({id:c.id,known:c.known,seen:c.seen})); localStorage.setItem(STORAGE_KEY, JSON.stringify(payload)); }
function loadProgress(){ try{ const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return; const arr = JSON.parse(raw); const map = new Map(arr.map(x=>[x.id,x])); deck.forEach(c=>{ const m = map.get(c.id); if(m){ c.known=!!m.known; c.seen=m.seen|0; } }); }catch(e){} }

// ===== Helpers =====
function normalizeId(raw){
  let s = String(raw).trim().toLowerCase();
  // Extract numeric part if present (card12 -> 12, 012 -> 12, "21" -> 21)
  const m = s.match(/(\d+)/);
  if(m){ return `card${parseInt(m[1],10)}`; }
  // If no digits, try to map words (e.g., "cardone" not supported â€” keep as-is)
  if(s.startsWith('card')) return s; // already good
  // last resort: assign sequential later; but include 'card' prefix now
  return s ? `card-${s}` : 'card0';
}

function parseCSV(str){
  const rows=[]; let row=[]; let cur=''; let i=0, inQ=false;
  while(i<str.length){
    const ch=str[i];
    if(inQ){
      if(ch==='"'){
        if(str[i+1]==='"'){ cur+='"'; i+=2; continue; }
        inQ=false; i++; continue;
      } else { cur+=ch; i++; continue; }
    } else {
      if(ch==='"'){ inQ=true; i++; continue; }
      if(ch===','){ row.push(cur); cur=''; i++; continue; }
      if(ch==='\n'){ row.push(cur); rows.push(row); row=[]; cur=''; i++; continue; }
      if(ch==='\r'){ i++; continue; }
      cur+=ch; i++;
    }
  }
  row.push(cur); rows.push(row);
  return rows.filter(r=> r.length>1 || (r.length===1 && r[0].trim()!==''));
}
function escape(s){ return (s||'').replace(/[&<>]/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[m])); }
</script>
</body>
</html>
