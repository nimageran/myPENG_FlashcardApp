<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0f172a" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="manifest" href="manifest.webmanifest" />
  <title>Flashcards — Nima (Images)</title>
  <style>
    :root { --bg:#0f172a; --card:#111827; --ink:#e5e7eb; --muted:#94a3b8; --accent:#22c55e; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; }
    .wrap { max-width: 680px; margin: 0 auto; padding: env(safe-area-inset-top) 16px env(safe-area-inset-bottom); }
    header { display: flex; align-items: center; justify-content: space-between; padding: 12px 0; position: sticky; top: 0; background: linear-gradient(to bottom, rgba(15,23,42,0.95), rgba(15,23,42,0)); backdrop-filter: blur(8px); z-index: 10; }
    h1 { font-size: 18px; margin: 0; opacity: .9; }
    button, input, textarea { font: inherit; }
    .btn { padding: 10px 14px; border-radius: 14px; border: 1px solid #334155; background: #0b1220; color: var(--ink); cursor: pointer; }
    .btn.primary { background: var(--accent); color: #03210f; border-color: #16a34a; font-weight: 600; }
    .grid { display: grid; gap: 12px; }
    .card { background: var(--card); border: 1px solid #1f2937; border-radius: 18px; padding: 16px; }
    .row { display:flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .row > * { flex: 1 1 auto; }
    textarea, input[type="text"] { width: 100%; padding: 12px 14px; border-radius: 12px; border: 1px solid #334155; background: #0b1220; color: var(--ink); }
    textarea { min-height: 80px; resize: vertical; }
    .tabs { display:flex; gap:6px; margin: 10px 0 6px; }
    .tab { padding: 8px 12px; border:1px solid #334155; border-radius: 999px; cursor: pointer; font-size: 14px; color: var(--muted); }
    .tab.active { color: var(--ink); border-color:#64748b; }
    .big { font-size: 22px; line-height: 1.35; text-align: center; min-height: 140px; padding: 18px; user-select: none; }
    .muted { color: var(--muted); font-size: 13px; }
    .pill { padding: 6px 10px; border-radius: 999px; border: 1px dashed #334155; color: var(--muted); }
    .actions { display:flex; gap:8px; justify-content: center; }
    .actions .btn { min-width: 90px; }
    .file { display:none; }
    .thumb { width: 44px; height: 44px; object-fit: cover; border-radius: 10px; border:1px solid #334155; }
    .review-img { max-width: 100%; max-height: 40vh; display: block; margin: 8px auto 6px; border-radius: 12px; border:1px solid #334155; }
    .footer { text-align:center; color: var(--muted); font-size: 12px; padding: 16px 0 48px; }
    .hint { font-size: 12px; color: var(--muted); }
    .nowrap { white-space: nowrap; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Flashcards — Nima</h1>
    <div class="row" style="gap:8px; justify-content:flex-end;">
      <button class="btn" id="installBtn" title="Install to Home Screen (PWA)" hidden>Install</button>
      <button class="btn" id="exportBtn" title="Download backup JSON">Export</button>
      <label class="btn" title="Import backup JSON/CSV">
        Import<input class="file" type="file" id="importFile" accept=".json,.csv,text/csv,application/json" />
      </label>
    </div>
  </header>

  <div class="tabs">
    <div class="tab active" data-tab="review">Review</div>
    <div class="tab" data-tab="add">Add</div>
    <div class="tab" data-tab="manage">Manage</div>
    <div class="tab" data-tab="sync">Sync</div>
  </div>

  <section id="review" class="grid">
    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="pill"><span id="dueCount">0</span> due</div>
        <div class="muted">Tap card to flip</div>
      </div>
      <div class="big" id="cardFace">
        No cards due. Add some or come back later.
      </div>
      <img id="cardImg" class="review-img" alt="" hidden>
      <div class="actions">
        <button class="btn" id="againBtn">Again</button>
        <button class="btn primary" id="goodBtn">Good</button>
        <button class="btn" id="easyBtn">Easy</button>
      </div>
    </div>
  </section>

  <section id="add" class="grid" hidden>
    <div class="card grid">
      <input type="text" id="front" placeholder="Front (question)" />
      <textarea id="back" placeholder="Back (answer)"></textarea>
      <div class="row" style="align-items:center; gap:8px;">
        <input type="text" id="imgUrl" placeholder="Image URL (optional)" />
        <label class="btn nowrap">Choose Image<input class="file" type="file" id="imgFile" accept="image/*"/></label>
        <button class="btn" id="uploadImgBtn" title="Upload selected image to GitHub and fill URL">Upload → GitHub</button>
      </div>
      <div class="hint">No GitHub? Leave URL empty or pick an image — it will be embedded locally (data URL).</div>
      <div class="row" style="justify-content:flex-end">
        <button class="btn primary" id="addBtn">Add Card</button>
      </div>
    </div>
    <div class="card muted">Tip: CSV supports only front,back. Use JSON to include an <code>img</code> field per card.</div>
  </section>

  <section id="manage" class="grid" hidden>
    <div class="card grid" id="list"></div>
  </section>

  <section id="sync" class="grid" hidden>
    <div class="card grid">
      <div class="muted">Optional sync & image upload via your GitHub repo (free). Create a Personal Access Token (classic) with <b>repo</b> (or just <b>contents:write</b>) scope. We store it locally on this device only.</div>
      <input type="text" id="ghToken" placeholder="GitHub token (stored locally)" />
      <input type="text" id="ghRepo" placeholder="Repo (e.g., youruser/nima-flashcards)" />
      <input type="text" id="ghBranch" placeholder="Branch (e.g., main)" value="main" />
      <input type="text" id="ghPath" placeholder="Assets folder path (e.g., assets)" value="assets" />
      <div class="row" style="justify-content:flex-end">
        <button class="btn" id="syncPull">Pull</button>
        <button class="btn primary" id="syncPush">Push</button>
      </div>
      <div class="muted" id="syncStatus"></div>
    </div>
  </section>

  <div class="footer">Offline-ready • Works on iPhone & laptop • PWA installable • Image upload to GitHub</div>
</div>

<script>
// ---------------- Core State ----------------
const KEY = "nima_flashcards_v2_images";
let state = load() || { cards: demo(), lastId: 0 };
let showingBack = false;
let currentId = null;

function demo(){
  return [
    mk("Torque = ?", "τ = r × F", ""),
    mk("PID stands for?", "Proportional–Integral–Derivative", ""),
    mk("Hooke’s law?", "σ = E ε", "")
  ];
}
function mk(front, back, img){
  return { id: ++window._id, front, back, img: img||"", intervalDays: 0, nextReview: Date.now() };
}
function load(){
  try { const s = JSON.parse(localStorage.getItem(KEY)); if(s && s.cards){ window._id = s.lastId||0; return s; } } catch(e){}
  window._id = 0; return null;
}
function save(){ localStorage.setItem(KEY, JSON.stringify(state)); }

function dueCards(){
  const now = Date.now();
  return state.cards.filter(c => c.nextReview <= now).sort((a,b)=>a.nextReview-b.nextReview);
}
function schedule(card, grade){
  let days = card.intervalDays || 0;
  if(grade==="again") days = 0.007;                // ~10 minutes
  if(grade==="good")  days = Math.max(1, days*2);  // 1d then double
  if(grade==="easy")  days = Math.max(3, days*3);  // 3d then triple
  card.intervalDays = days;
  const base = Date.now() + (grade==="again" ? 10*60*1000 : 0);
  card.nextReview = base + days*86400*1000;
  save();
}

// ---------------- UI ----------------
const qs = s=>document.querySelector(s);
const qsa = s=>Array.from(document.querySelectorAll(s));
const face = qs("#cardFace");
const faceImg = qs("#cardImg");

function renderList(){
  const wrap = qs("#list");
  if(!state.cards.length){ wrap.innerHTML = '<div class="muted">No cards yet.</div>'; return; }
  wrap.innerHTML = state.cards.map(c=>`
    <div class="row" data-id="${c.id}">
      <img class="thumb" src="${c.img||''}" alt="" onerror="this.hidden=true" ${c.img?"":"hidden"}>
      <div style="flex:2">
        <div><b>${escapeHtml(c.front)}</b></div>
        <div class="muted">${escapeHtml(c.back)}</div>
      </div>
      <div class="muted" style="min-width:110px;text-align:right">${new Date(c.nextReview).toLocaleDateString()}</div>
      <button class="btn" data-act="edit">Edit</button>
      <button class="btn" data-act="del">Delete</button>
    </div>
  `).join("");
  wrap.onclick = (e)=>{
    const btn = e.target.closest("button"); if(!btn) return;
    const row = e.target.closest("[data-id]"); const id = +row.dataset.id;
    const idx = state.cards.findIndex(c=>c.id===id);
    if(btn.dataset.act==="del"){ state.cards.splice(idx,1); save(); renderList(); renderDue(); }
    if(btn.dataset.act==="edit"){
      const c = state.cards[idx];
      const nf = prompt("Front:", c.front); if(nf===null) return;
      const nb = prompt("Back:", c.back); if(nb===null) return;
      const ni = prompt("Image URL (leave empty to remove):", c.img||""); if(ni===null) return;
      c.front = nf; c.back = nb; c.img = ni.trim(); save(); renderList(); }
  };
}
function renderDue(){
  const due = dueCards();
  qs("#dueCount").textContent = String(due.length);
  if(!due.length){ face.textContent = "No cards due. Add some or come back later."; faceImg.hidden = true; currentId=null; showingBack=false; return; }
  const c = due[0];
  currentId = c.id;
  face.innerHTML = showingBack ? escapeHtml(c.back) : escapeHtml(c.front);
  if(c.img){ faceImg.src = c.img; faceImg.hidden = false; }
  else { faceImg.hidden = true; }
}
function escapeHtml(s){ return (s||"").replace(/[&<>]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[m])); }

// Tabs
qsa(".tab").forEach(t=>t.addEventListener("click", ()=>{
  qsa(".tab").forEach(x=>x.classList.remove("active"));
  t.classList.add("active");
  const id = t.dataset.tab;
  qsa("section").forEach(s=>s.hidden = (s.id!==id));
}));

// Review
face.addEventListener("click", ()=>{ showingBack = !showingBack; renderDue(); });
qs("#againBtn").onclick = ()=>grade("again");
qs("#goodBtn").onclick  = ()=>grade("good");
qs("#easyBtn").onclick  = ()=>grade("easy");
function grade(g){
  const card = state.cards.find(c=>c.id===currentId);
  if(!card) return;
  schedule(card, g);
  showingBack = false;
  renderDue();
}

// Add
qs("#addBtn").onclick = ()=>{
  const f = qs("#front").value.trim();
  const b = qs("#back").value.trim();
  let img = qs("#imgUrl").value.trim();
  const file = qs("#imgFile").files[0];
  if(!f || !b) return;
  if(!img && file){ // embed data URL locally if no GitHub upload
    const fr = new FileReader();
    fr.onload = () => { addCard(f,b, fr.result); };
    fr.readAsDataURL(file);
  } else {
    addCard(f,b,img);
  }
};
function addCard(f,b,img){
  const c = mk(f,b,img);
  state.cards.push(c); state.lastId = Math.max(state.lastId||0, c.id); save();
  qs("#front").value = ""; qs("#back").value = ""; qs("#imgUrl").value = ""; qs("#imgFile").value = "";
  renderList(); renderDue();
}

// GitHub Image Upload → fills the Image URL field
qs("#uploadImgBtn").onclick = async ()=>{
  const file = qs("#imgFile").files[0];
  if(!file){ note("Pick an image first."); return; }
  try{
    const { token, repo, branch, path } = ghCfg();
    if(!token || !repo){ note("Set token & repo in Sync tab."); return; }
    const name = suggestName(file.name);
    const content = await file.arrayBuffer();
    const b64 = base64Encode(new Uint8Array(content));
    const res = await fetch(`https://api.github.com/repos/${repo}/contents/${path}/${name}?ref=${encodeURIComponent(branch)}`,{
      method: "PUT",
      headers: { "Authorization": `token ${token}`, "Accept": "application/vnd.github+json" },
      body: JSON.stringify({ message: `Add asset: ${name}`, content: b64, branch })
    });
    if(!res.ok){ throw new Error(await res.text()); }
    const json = await res.json();
    const url = json.content.download_url; // CDN-ish link
    qs("#imgUrl").value = url;
    note("Image uploaded ✔");
  }catch(e){ note("Upload failed: "+e.message); }
};
function suggestName(fname){
  const stamp = new Date().toISOString().replace(/[:.]/g, "-");
  const clean = fname.toLowerCase().replace(/[^a-z0-9_.-]/g, "-");
  return `${stamp}-${clean}`;
}
function base64Encode(bytes){
  let bin = ""; for (let i=0; i<bytes.length; i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}

// Import / Export (CSV + JSON with optional img)
qs("#exportBtn").onclick = ()=>{
  const blob = new Blob([JSON.stringify(state,null,2)], {type:"application/json"});
  const a = document.createElement("a"); a.href = URL.createObjectURL(blob);
  a.download = "flashcards-backup.json"; a.click();
};
qs("#importFile").addEventListener("change", async (e)=>{
  const file = e.target.files[0]; if(!file) return;
  const text = await file.text();
  try {
    if(file.name.endsWith(".csv")){
      const rows = text.split(/\r?\n/).slice(1).map(l=>l.split(",")); // naive CSV
      for(const r of rows){
        if(r.length>=2 && r[0].trim() && r[1].trim()){
          state.cards.push(mk(r[0].trim(), r[1].trim(), ""));
          state.lastId = (state.lastId||0) + 1;
        }
      }
      save();
    } else {
      const obj = JSON.parse(text);
      if(obj.cards){ state.cards = obj.cards.map(c=> mk(c.front||"", c.back||"", c.img||"")); }
      else if(Array.isArray(obj)){ state.cards = obj.map(c=> mk(c.front||"", c.back||"", c.img||"")); }
      else { throw new Error("Unrecognized JSON shape"); }
      // reset ids monotonic
      state.cards.forEach((c,i)=> c.id = i+1); state.lastId = state.cards.length; save();
    }
    renderList(); renderDue(); note("Import ✔");
  } catch(err){ alert("Import failed: " + err); }
  finally { e.target.value = ""; }
});

// Optional: Gist Sync for deck JSON (not images)
qs("#syncPush").onclick = ()=>sync("push");
qs("#syncPull").onclick = ()=>sync("pull");
async function sync(dir){
  const token = localStorage.getItem("gh_token")||"";
  const gistId = localStorage.getItem("gh_gist")||"";
  if(!token){ note("Set GitHub token."); return; }
  try{
    if(dir==="push"){
      const url = gistId ? `https://api.github.com/gists/${gistId}` : "https://api.github.com/gists";
      const res = await fetch(url,{
        method: gistId ? "PATCH" : "POST",
        headers:{"Authorization":`token ${token}","Accept":"application/vnd.github+json"},
        body: JSON.stringify({ description: "Nima Flashcards", public: false, files: { "flashcards.json": { content: JSON.stringify(state) } } })
      });
      if(!res.ok) throw new Error(await res.text());
      const json = await res.json();
      localStorage.setItem("gh_gist", json.id);
      note("Pushed ✔");
    } else {
      const id = gistId; if(!id){ note("Set Gist ID by pushing once first."); return; }
      const res = await fetch(`https://api.github.com/gists/${id}`,{ headers:{"Authorization":`token ${token}"}});
      if(!res.ok) throw new Error(await res.text());
      const json = await res.json();
      const file = json.files["flashcards.json"]; const content = file.truncated ? await (await fetch(file.raw_url)).text() : file.content;
      state = JSON.parse(content); save(); renderList(); renderDue(); note("Pulled ✔");
    }
  }catch(e){ note("Sync failed: "+e.message); }
}

// GitHub Repo config helpers for image upload
function ghCfg(){
  const token = qs("#ghToken").value.trim() || localStorage.getItem("gh_token") || "";
  const repo  = qs("#ghRepo").value.trim()  || localStorage.getItem("gh_repo")  || "";
  const branch= qs("#ghBranch").value.trim()|| localStorage.getItem("gh_branch")|| "main";
  const path  = (qs("#ghPath").value.trim() || localStorage.getItem("gh_path") || "assets").replace(/^\/+|\/+$/g, "");
  // persist silently
  localStorage.setItem("gh_token", token);
  localStorage.setItem("gh_repo", repo);
  localStorage.setItem("gh_branch", branch);
  localStorage.setItem("gh_path", path);
  return { token, repo, branch, path };
}
function note(msg){ qs("#syncStatus").textContent = msg; setTimeout(()=>qs("#syncStatus").textContent="", 4000); }

// ---------------- PWA ----------------
let deferredPrompt;
window.addEventListener("beforeinstallprompt", (e)=>{ e.preventDefault(); deferredPrompt = e; qs("#installBtn").hidden = false; });
qs("#installBtn").onclick = async ()=>{ if(!deferredPrompt) return; deferredPrompt.prompt(); await deferredPrompt.userChoice; qs("#installBtn").hidden = true; };
if("serviceWorker" in navigator){ navigator.serviceWorker.register("sw.js"); }

// init
renderList(); renderDue();
</script>
</body>
</html>
