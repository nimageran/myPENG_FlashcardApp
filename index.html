<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0f172a" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="manifest" href="manifest.webmanifest" />
  <title>Flashcards — Nima (CSV + Images)</title>
  <style>
    :root { --bg:#0f172a; --card:#111827; --ink:#e5e7eb; --muted:#94a3b8; --accent:#22c55e; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; }
    .wrap { max-width: 720px; margin: 0 auto; padding: env(safe-area-inset-top) 16px env(safe-area-inset-bottom); }
    header { display: flex; align-items: center; justify-content: space-between; padding: 12px 0; position: sticky; top: 0; background: linear-gradient(to bottom, rgba(15,23,42,0.95), rgba(15,23,42,0)); backdrop-filter: blur(8px); z-index: 10; }
    h1 { font-size: 18px; margin: 0; opacity: .9; }
    button, input, textarea, select { font: inherit; }
    .btn { padding: 10px 14px; border-radius: 14px; border: 1px solid #334155; background: #0b1220; color: var(--ink); cursor: pointer; }
    .btn.primary { background: var(--accent); color: #03210f; border-color: #16a34a; font-weight: 600; }
    .grid { display: grid; gap: 12px; }
    .card { background: var(--card); border: 1px solid #1f2937; border-radius: 18px; padding: 16px; }
    .row { display:flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .row > * { flex: 1 1 auto; }
    textarea, input[type="text"], input[type="url"], select { width: 100%; padding: 12px 14px; border-radius: 12px; border: 1px solid #334155; background: #0b1220; color: var(--ink); }
    textarea { min-height: 80px; resize: vertical; }
    .tabs { display:flex; gap:6px; margin: 10px 0 6px; }
    .tab { padding: 8px 12px; border:1px solid #334155; border-radius: 999px; cursor: pointer; font-size: 14px; color: var(--muted); }
    .tab.active { color: var(--ink); border-color:#64748b; }
    .big { font-size: 22px; line-height: 1.35; text-align: center; min-height: 140px; padding: 18px; user-select: none; }
    .muted { color: var(--muted); font-size: 13px; }
    .pill { padding: 6px 10px; border-radius: 999px; border: 1px dashed #334155; color: var(--muted); }
    .actions { display:flex; gap:8px; justify-content: center; }
    .actions .btn { min-width: 90px; }
    .file { display:none; }
    .thumb { width: 44px; height: 44px; object-fit: cover; border-radius: 10px; border:1px solid #334155; }
    .review-img { max-width: 100%; max-height: 40vh; display: block; margin: 8px auto 6px; border-radius: 12px; border:1px solid #334155; }
    .footer { text-align:center; color: var(--muted); font-size: 12px; padding: 16px 0 48px; }
    .hint { font-size: 12px; color: var(--muted); }
    .nowrap { white-space: nowrap; }
    .toggle { display:flex; align-items:center; gap:8px; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Flashcards — Nima</h1>
    <div class="row" style="gap:8px; justify-content:flex-end;">
      <label class="toggle pill"><input type="checkbox" id="randomMode"> Random</label>
      <button class="btn" id="installBtn" title="Install to Home Screen (PWA)" hidden>Install</button>
      <button class="btn" id="exportBtn" title="Download backup JSON">Export</button>
      <label class="btn" title="Import backup JSON/CSV">
        Import<input class="file" type="file" id="importFile" accept=".json,.csv,text/csv,application/json" />
      </label>
    </div>
  </header>

  <div class="tabs">
    <div class="tab active" data-tab="review">Review</div>
    <div class="tab" data-tab="add">Add</div>
    <div class="tab" data-tab="manage">Manage</div>
    <div class="tab" data-tab="sync">Sync</div>
  </div>

  <section id="review" class="grid">
    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="pill"><span id="dueCount">0</span> <span id="dueLabel">due</span></div>
        <div class="muted">Tap card to flip</div>
      </div>
      <div class="big" id="cardFace">No cards due. Add some or load CSV.</div>
      <img id="cardImg" class="review-img" alt="" hidden>
      <div class="actions">
        <button class="btn" id="againBtn">Again</button>
        <button class="btn primary" id="goodBtn">Good</button>
        <button class="btn" id="easyBtn">Easy</button>
      </div>
    </div>
  </section>

  <section id="add" class="grid" hidden>
    <div class="card grid">
      <input type="text" id="front" placeholder="Front (question)" />
      <textarea id="back" placeholder="Back (answer)"></textarea>
      <div class="row" style="align-items:center; gap:8px;">
        <input type="text" id="imgUrl" placeholder="Image URL (optional)" />
        <label class="btn nowrap">Choose Image<input class="file" type="file" id="imgFile" accept="image/*"/></label>
        <button class="btn" id="uploadImgBtn" title="Upload selected image to GitHub and fill URL">Upload → GitHub</button>
      </div>
      <div class="hint">CSV supports two columns: <code>front,back</code>. Use JSON to include an optional <code>img</code> per card.</div>
      <div class="row" style="justify-content:flex-end">
        <button class="btn primary" id="addBtn">Add Card</button>
      </div>
    </div>
  </section>

  <section id="manage" class="grid" hidden>
    <div class="card grid" id="list"></div>
  </section>

  <section id="sync" class="grid" hidden>
    <div class="card grid">
      <div class="muted">Optional sync & image upload via your GitHub repo. Personal Access Token (classic) with <b>repo</b> or <b>contents:write</b>.</div>
      <input type="text" id="ghToken" placeholder="GitHub token (stored locally)" />
      <input type="text" id="ghRepo" placeholder="Repo (e.g., youruser/nima-flashcards)" />
      <input type="text" id="ghBranch" placeholder="Branch (e.g., main)" value="main" />
      <input type="text" id="ghPath" placeholder="Assets folder path (e.g., assets)" value="assets" />
      <div class="row" style="justify-content:flex-end">
        <button class="btn" id="syncPull">Pull</button>
        <button class="btn primary" id="syncPush">Push</button>
      </div>
      <div class="muted" id="syncStatus"></div>
    </div>
    <div class="card grid">
      <div class="muted">Load your deck directly from a CSV in your repo (e.g., <code>assets/cards.csv</code>). Two columns: <b>front,back</b>. Header row optional.</div>
      <input type="url" id="csvUrl" placeholder="CSV URL (e.g., https://youruser.github.io/nima-flashcards/assets/cards.csv)" />
      <div class="row" style="justify-content:flex-end">
        <button class="btn primary" id="csvLoad">Load CSV</button>
      </div>
      <div class="muted">Tip: when CSV is loaded, toggle <b>Random</b> at the top to quiz yourself like classic flashcards.</div>
    </div>
  </section>

  <div class="footer">Offline-ready • iPhone & laptop • PWA installable • CSV deck • Image upload to GitHub</div>
</div>

<script>
// ---------------- Core State ----------------
const KEY = "nima_flashcards_v3_csv";
let state = load() || { cards: demo(), lastId: 0 };
let showingBack = false;
let currentId = null;
let csvMode = false; // if true, Random toggle controls picking from CSV deck

function demo(){
  return [
    mk("Torque = ?", "τ = r × F", ""),
    mk("PID stands for?", "Proportional–Integral–Derivative", ""),
    mk("Hooke’s law?", "σ = E ε", "")
  ];
}
function mk(front, back, img){
  return { id: ++window._id, front, back, img: img||"", intervalDays: 0, nextReview: Date.now() };
}
function load(){
  try { const s = JSON.parse(localStorage.getItem(KEY)); if(s && s.cards){ window._id = s.lastId||0; return s; } } catch(e){}
  window._id = 0; return null;
}
function save(){ localStorage.setItem(KEY, JSON.stringify(state)); }

function dueCards(){
  const now = Date.now();
  return state.cards.filter(c => c.nextReview <= now).sort((a,b)=>a.nextReview-b.nextReview);
}
function schedule(card, grade){
  let days = card.intervalDays || 0;
  if(grade==="again") days = 0.007;                // ~10 minutes
  if(grade==="good")  days = Math.max(1, days*2);  // 1d then double
  if(grade==="easy")  days = Math.max(3, days*3);  // 3d then triple
  card.intervalDays = days;
  const base = Date.now() + (grade==="again" ? 10*60*1000 : 0);
  card.nextReview = base + days*86400*1000;
  save();
}

// ---------------- UI ----------------
const qs = s=>document.querySelector(s);
const qsa = s=>Array.from(document.querySelectorAll(s));
const face = qs("#cardFace");
const faceImg = qs("#cardImg");

function renderList(){
  const wrap = qs("#list");
  if(!state.cards.length){ wrap.innerHTML = '<div class="muted">No cards yet.</div>'; return; }
  wrap.innerHTML = state.cards.map(c=>`
    <div class="row" data-id="${c.id}">
      <img class="thumb" src="${c.img||''}" alt="" onerror="this.hidden=true" ${c.img?"":"hidden"}>
      <div style="flex:2">
        <div><b>${escapeHtml(c.front)}</b></div>
        <div class="muted">${escapeHtml(c.back)}</div>
      </div>
      <div class="muted" style="min-width:110px;text-align:right">${new Date(c.nextReview).toLocaleDateString()}</div>
      <button class="btn" data-act="edit">Edit</button>
      <button class="btn" data-act="del">Delete</button>
    </div>
  `).join("");
  wrap.onclick = (e)=>{
    const btn = e.target.closest("button"); if(!btn) return;
    const row = e.target.closest("[data-id]"); const id = +row.dataset.id;
    const idx = state.cards.findIndex(c=>c.id===id);
    if(btn.dataset.act==="del"){ state.cards.splice(idx,1); save(); renderList(); renderDue(); }
    if(btn.dataset.act==="edit"){
      const c = state.cards[idx];
      const nf = prompt("Front:", c.front); if(nf===null) return;
      const nb = prompt("Back:", c.back); if(nb===null) return;
      const ni = prompt("Image URL (leave empty to remove):", c.img||""); if(ni===null) return;
      c.front = nf; c.back = nb; c.img = ni.trim(); save(); renderList(); }
  };
}
function renderDue(){
  const random = qs('#randomMode').checked;
  const label = qs('#dueLabel');
  if(random){
    label.textContent = 'in deck';
    qs('#dueCount').textContent = String(state.cards.length);
    showCardRandom();
    return;
  }
  const due = dueCards();
  qs('#dueCount').textContent = String(due.length);
  label.textContent = 'due';
  if(!due.length){ face.textContent = "No cards due. Add some or load CSV."; faceImg.hidden = true; currentId=null; showingBack=false; return; }
  const c = due[0];
  currentId = c.id;
  face.innerHTML = showingBack ? escapeHtml(c.back) : escapeHtml(c.front);
  if(c.img){ faceImg.src = c.img; faceImg.hidden = false; } else { faceImg.hidden = true; }
}
function showCardRandom(){
  if(!state.cards.length){ face.textContent = "No cards loaded. Load a CSV or add cards."; faceImg.hidden = true; return; }
  const idx = Math.floor(Math.random()*state.cards.length);
  const c = state.cards[idx];
  currentId = c.id;
  showingBack = false;
  face.innerHTML = escapeHtml(c.front);
  if(c.img){ faceImg.src = c.img; faceImg.hidden = false; } else { faceImg.hidden = true; }
}
function escapeHtml(s){ return (s||"").replace(/[&<>]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[m])); }

// Tabs
qsa(".tab").forEach(t=>t.addEventListener("click", ()=>{
  qsa(".tab").forEach(x=>x.classList.remove("active"));
  t.classList.add("active");
  const id = t.dataset.tab;
  qsa("section").forEach(s=>s.hidden = (s.id!==id));
}));

// Review
face.addEventListener("click", ()=>{
  const random = qs('#randomMode').checked;
  if(!currentId){ return; }
  if(random){
    // flip front/back only; advancing happens when grading buttons are pressed
    showingBack = !showingBack;
    const c = state.cards.find(c=>c.id===currentId);
    face.innerHTML = showingBack ? escapeHtml(c.back) : escapeHtml(c.front);
    return;
  }
  showingBack = !showingBack; renderDue();
});
qs("#againBtn").onclick = ()=>grade("again");
qs("#goodBtn").onclick  = ()=>grade("good");
qs("#easyBtn").onclick  = ()=>grade("easy");
function grade(g){
  const random = qs('#randomMode').checked;
  if(random){ showCardRandom(); return; }
  const card = state.cards.find(c=>c.id===currentId);
  if(!card) return;
  schedule(card, g);
  showingBack = false;
  renderDue();
}
qs('#randomMode').addEventListener('change', ()=>{ showingBack=false; renderDue(); });

// Add (manual + optional image upload)
qs("#addBtn").onclick = ()=>{
  const f = qs("#front").value.trim();
  const b = qs("#back").value.trim();
  let img = qs("#imgUrl").value.trim();
  const file = qs("#imgFile").files[0];
  if(!f || !b) return;
  if(!img && file){
    const fr = new FileReader();
    fr.onload = () => { addCard(f,b, fr.result); };
    fr.readAsDataURL(file);
  } else { addCard(f,b,img); }
};
function addCard(f,b,img){
  const c = mk(f,b,img);
  state.cards.push(c); state.lastId = Math.max(state.lastId||0, c.id); save();
  qs("#front").value = ""; qs("#back").value = ""; qs("#imgUrl").value = ""; qs("#imgFile").value = "";
  renderList(); renderDue();
}

// GitHub Image Upload → fills the Image URL field
qs("#uploadImgBtn").onclick = async ()=>{
  const file = qs("#imgFile").files[0];
  if(!file){ note("Pick an image first."); return; }
  try{
    const { token, repo, branch, path } = ghCfg();
    if(!token || !repo){ note("Set token & repo in Sync tab."); return; }
    const name = suggestName(file.name);
    const content = await file.arrayBuffer();
    const b64 = base64Encode(new Uint8Array(content));
    const res = await fetch(`https://api.github.com/repos/${repo}/contents/${path}/${name}?ref=${encodeURIComponent(branch)}`,{
      method: "PUT",
      headers: { "Authorization": `token ${token}`, "Accept": "application/vnd.github+json" },
      body: JSON.stringify({ message: `Add asset: ${name}`, content: b64, branch })
    });
    if(!res.ok){ throw new Error(await res.text()); }
    const json = await res.json();
    const url = json.content.download_url;
    qs("#imgUrl").value = url;
    note("Image uploaded ✔");
  }catch(e){ note("Upload failed: "+e.message); }
};
function suggestName(fname){
  const stamp = new Date().toISOString().replace(/[:.]/g, "-");
  const clean = fname.toLowerCase().replace(/[^a-z0-9_.-]/g, "-");
  return `${stamp}-${clean}`;
}
function base64Encode(bytes){ let bin = ""; for (let i=0; i<bytes.length; i++) bin += String.fromCharCode(bytes[i]); return btoa(bin); }

// Import / Export (CSV + JSON with optional img)
qs("#exportBtn").onclick = ()=>{
  const blob = new Blob([JSON.stringify(state,null,2)], {type:"application/json"});
  const a = document.createElement("a"); a.href = URL.createObjectURL(blob);
  a.download = "flashcards-backup.json"; a.click();
};
qs("#importFile").addEventListener("change", async (e)=>{
  const file = e.target.files[0]; if(!file) return;
  const text = await file.text();
  try {
    if(file.name.endsWith(".csv")){
      const rows = parseCSV(text); // robust CSV
      // Skip header if it looks like one
      const header = rows[0] || [];
      const start = header && header[0] && header[1] && header[0].toLowerCase()==='front' && header[1].toLowerCase()==='back' ? 1 : 0;
      const items = rows.slice(start).filter(r=> (r[0]||'').trim() && (r[1]||'').trim());
      state.cards = items.map(r=> mk(r[0].trim(), r[1].trim(), ""));
      state.cards.forEach((c,i)=> c.id = i+1); state.lastId = state.cards.length; save();
    } else {
      const obj = JSON.parse(text);
      if(obj.cards){ state.cards = obj.cards.map(c=> mk(c.front||"", c.back||"", c.img||"")); }
      else if(Array.isArray(obj)){ state.cards = obj.map(c=> mk(c.front||"", c.back||"", c.img||"")); }
      else { throw new Error("Unrecognized JSON shape"); }
      state.cards.forEach((c,i)=> c.id = i+1); state.lastId = state.cards.length; save();
    }
    renderList(); renderDue(); note("Import ✔");
  } catch(err){ alert("Import failed: " + err); }
  finally { e.target.value = ""; }
});

// Load CSV from URL (GitHub Pages URL works)
qs('#csvLoad').onclick = async ()=>{
  const url = qs('#csvUrl').value.trim();
  if(!url){ note('Paste a CSV URL.'); return; }
  try{
    const text = await (await fetch(url, {cache:'no-store'})).text();
    const rows = parseCSV(text);
    const header = rows[0] || [];
    const start = header && header[0] && header[1] && header[0].toLowerCase()==='front' && header[1].toLowerCase()==='back' ? 1 : 0;
    const items = rows.slice(start).filter(r=> (r[0]||'').trim() && (r[1]||'').trim());
    state.cards = items.map(r=> mk(r[0].trim(), r[1].trim(), ""));
    state.cards.forEach((c,i)=> c.id = i+1); state.lastId = state.cards.length; save();
    csvMode = true; qs('#randomMode').checked = true; renderList(); renderDue(); note('CSV loaded ✔');
  }catch(e){ note('CSV load failed: '+e.message); }
};

// Simple RFC4180-ish CSV parser (quotes, commas, newlines)
function parseCSV(str){
  const rows = []; let row = []; let cur = '';
  let i=0, inQuotes=false;
  while(i < str.length){
    const ch = str[i];
    if(inQuotes){
      if(ch==='"'){
        if(str[i+1]==='"'){ cur+='"'; i+=2; continue; }
        inQuotes = false; i++; continue;
      } else { cur += ch; i++; continue; }
    } else {
      if(ch==='"'){ inQuotes = true; i++; continue; }
      if(ch===','){ row.push(cur); cur=''; i++; continue; }
      if(ch==='\n'){ row.push(cur); rows.push(row); row=[]; cur=''; i++; continue; }
      if(ch==='\r'){ i++; continue; }
      cur += ch; i++;
    }
  }
  row.push(cur); rows.push(row);
  // trim possible trailing empty lines
  return rows.filter(r=> r.length>1 || (r.length===1 && r[0].trim()!==''));
}

// Optional: Gist Sync for deck JSON (not images)
qs("#syncPush").onclick = ()=>sync("push");
qs("#syncPull").onclick = ()=>sync("pull");
async function sync(dir){
  const token = localStorage.getItem("gh_token")||"";
  const gistId = localStorage.getItem("gh_gist")||"";
  if(!token){ note("Set GitHub token."); return; }
  try{
    if(dir==="push"){
      const url = gistId ? `https://api.github.com/gists/${gistId}` : "https://api.github.com/gists";
      const res = await fetch(url,{
        method: gistId ? "PATCH" : "POST",
        headers:{"Authorization":`token ${token}","Accept":"application/vnd.github+json"},
        body: JSON.stringify({ description: "Nima Flashcards", public: false, files: { "flashcards.json": { content: JSON.stringify(state) } } })
      });
      if(!res.ok) throw new Error(await res.text());
      const json = await res.json();
      localStorage.setItem("gh_gist", json.id);
      note("Pushed ✔");
    } else {
      const id = gistId; if(!id){ note("Set Gist ID by pushing once first."); return; }
      const res = await fetch(`https://api.github.com/gists/${id}`,{ headers:{"Authorization":`token ${token}"}});
      if(!res.ok) throw new Error(await res.text());
      const json = await res.json();
      const file = json.files["flashcards.json"]; const content = file.truncated ? await (await fetch(file.raw_url)).text() : file.content;
      state = JSON.parse(content); save(); renderList(); renderDue(); note("Pulled ✔");
    }
  }catch(e){ note("Sync failed: "+e.message); }
}

// GitHub Repo config helpers for image upload
function ghCfg(){
  const token = qs("#ghToken").value.trim() || localStorage.getItem("gh_token") || "";
  const repo  = qs("#ghRepo").value.trim()  || localStorage.getItem("gh_repo")  || "";
  const branch= qs("#ghBranch").value.trim()|| localStorage.getItem("gh_branch")|| "main";
  const path  = (qs("#ghPath").value.trim() || localStorage.getItem("gh_path") || "assets").replace(/^\/+|\/+$/g, "");
  localStorage.setItem("gh_token", token);
  localStorage.setItem("gh_repo", repo);
  localStorage.setItem("gh_branch", branch);
  localStorage.setItem("gh_path", path);
  return { token, repo, branch, path };
}
function note(msg){ qs("#syncStatus").textContent = msg; setTimeout(()=>qs("#syncStatus").textContent="", 4000); }

// ---------------- PWA ----------------
let deferredPrompt;
window.addEventListener("beforeinstallprompt", (e)=>{ e.preventDefault(); deferredPrompt = e; qs("#installBtn").hidden = false; });
qs("#installBtn").onclick = async ()=>{ if(!deferredPrompt) return; deferredPrompt.prompt(); await deferredPrompt.userChoice; qs("#installBtn").hidden = true; };
if("serviceWorker" in navigator){ navigator.serviceWorker.register("sw.js"); }

// init
renderList(); renderDue();
</script>
</body>
</html>
